// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// ================================
/// Users and auth
/// ================================

model User {
  id       String      @id @default(cuid())
  email    String   @unique
  name     String?
  bio      String?    @db.Text
  lastSeen DateTime?
  avatarUrl String?
  address   String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  refreshToken RefreshToken[]

  followers Follow[] @relation("followers")
  following Follow[] @relation("following")

  // Item relations
  items Item[] @relation("ItemSold")
  // Like relations
  itemCollects    ItemCollection[] @relation("UserItemCollection")
  // Comment relations
  comments Comment[] @relation("UserComments")
  // 
  commentLikes  CommentLike[] @relation("UserCommentLikes")
  // Order relations
  purchases Order[] @relation("ItemBought")
  sales     Order[] @relation("OrderAsSeller")
  
  // Messaging relations
  sentMessages     Message[] @relation("MessageSender")
  conversationParticipants ConversationParticipant[]
  messageDeliveries MessageDelivery[]
  
  // Push notification relations
  deviceTokens     DeviceToken[] @relation("UserDeviceTokens")

  @@map("user")
}

model RefreshToken {
  id          String    @id @default(cuid())
  token       String    @unique
  userId      String    @map("user_id")
  user        User      @relation(fields: [userId], references: [id])
  createdAt    DateTime  @default(now()) @map("created_at")
  expireAt    DateTime @map("expire_at")
  revoked     Boolean   @default(false)
  deviceInfo  String? @map("device_info")

  @@map("refresh-token")

}

/// ================================
/// Follow
/// ================================

model Follow {
  id String @id @default(cuid())

  followerId String @map("follower_id")
  followingId String @map("following_id")
  createdAt DateTime @default(now()) @map("created_at")
  
  follower User @relation("following", fields: [followerId], references: [id])
  following User @relation("followers", fields: [followingId], references: [id])

  @@unique([followerId, followingId], name: "unique_follow")
  @@index([followerId])
  @@index([followingId])

  @@map("follow")
}


/// ================================
/// Items and its relations
/// ================================

model Item {
  id          String      @id @default(cuid())
  title       String
  description String?  @db.Text
  price       Decimal  @db.Decimal(10, 2) //This stores up to 10 digits, with 2 for cents.
  oldPrice    Decimal  @db.Decimal(10, 2)
  condition   ItemCondition @default(USED)
  status     ItemStatus  @default(AVAILABLE)
  location    String?
  
  sellerId    String   @map("seller_id")
  seller      User     @relation("ItemSold", fields: [sellerId], references: [id], onDelete: Cascade)

  //category
  categoryId  String   @map("category_id")
  category    Category  @relation(fields: [categoryId], references: [id])
  
  //relationships
  images      Image[]
  comments    Comment[]
  collectedBy     ItemCollection[] @relation("ItemCollects")
  collectionsCount Int @default(0) @map("collections_count")
  order       Order?
  conversations   Conversation[]
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@map("item")
}

enum ItemCondition {
  NEW
  LIKE_NEW
  USED
  FOR_PARTS
}

enum ItemStatus {
  AVAILABLE
  RESERVED
  PENDING
  SOLD
  HIDDEN
}

model Image {
  id           String  @id @default(cuid())
  url          String
  // Let the best one can be showed as a cover photo
  sort         Int
  itemId       String  @map("item_id")
  item         Item    @relation(fields: [itemId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now()) @map("created_at")

  @@index([id])

  @@map("image")
}

model Category {
  id           String @id @default(cuid())
  name         String @unique // e.g., "Electronics", "Clothing", "Books"
  // For example, "Mobile Phones" can be a sub-category of "Electronics".
  // `parentId` points to the ID of the parent category.
  parentId     String? @map("parent_id")
  parent       Category? @relation("SubCategories", fields: [parentId], references: [id])
  children     Category[] @relation("SubCategories")

  item         Item[]

  @@index([parentId])

  @@map("category")
}

model Comment {
  id           String @id  @default(cuid())
  content      String  @db.Text()

  authorId     String  @map("author_id")
  author       User    @relation("UserComments", fields: [authorId], references: [id])

  itemId       String  @map("item_id")
  item         Item    @relation(fields: [itemId], references: [id], onDelete: Cascade)

  parentId     String?
  parent       Comment? @relation("Replies", fields: [parentId], references: [id], onDelete: NoAction)
  replies      Comment[] @relation("Replies")

  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  likedBy      CommentLike[] @relation("CommentLikes")
  likedCount   Int            @default(0)

  @@index([itemId, createdAt]) // Index for fetching comments for an item, sorted by date.
  @@index([authorId])

  @@map("comment")
}

model ItemCollection {
  userId       String @map("user_id")
  user         User @relation("UserItemCollection", fields: [userId], references: [id], onDelete: Cascade)


  itemId       String @map("item_id")
  item         Item @relation("ItemCollects", fields: [itemId], references: [id], onDelete: Cascade)

  createdAt    DateTime @default(now()) @map("created_at")


  @@id([itemId, userId])

  @@map("item_collection")
}

model CommentLike {
  userId      String @map("user_id")
  user        User   @relation("UserCommentLikes", fields: [userId], references: [id], onDelete: Cascade)

  commentId      String @map("comment_id")
  comment     Comment  @relation("CommentLikes", fields: [commentId], references: [id], onDelete: Cascade)

  @@id([userId, commentId])
  @@map("comment_like")
}

model Order {
  id          String @id  @default(cuid())
  
  itemId      String  @unique @map("item_id")
  item        Item    @relation(fields: [itemId], references: [id])

  buyerId     String  @map("buyer_id")
  buyer       User    @relation("ItemBought",fields: [buyerId], references: [id])

  sellerId    String  @map("seller_id")
  seller      User    @relation("OrderAsSeller", fields: [sellerId], references: [id])

  purchasPrice Decimal @db.Decimal(10, 2) @map("purchas_price")

  status      OrderStatus @default(PAYMENT_PENDING)

  shippingAddress String @db.Text @map("shipping_address")

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@index([buyerId])
  @@index([sellerId])

  @@map("order")
}

enum OrderStatus {
  PAYMENT_PENDING
  PAID
  SHIPPED
  DELIVERED
  COMPLETED
  CANCELED
  REFUSED
}

/// ================================
/// Messaging System
/// ================================

model Conversation {
  id              String @id @default(cuid())
  type            ConversationType @default(DIRECT_MESSAGE)
  title           String? // For group chats
  itemId          String? @map("item_id") // For item-related conversations
  item            Item? @relation(fields: [itemId], references: [id], onDelete: SetNull)
  
  lastMessageAt   DateTime? @map("last_message_at")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  
  participants    ConversationParticipant[]
  messages        Message[]
  
  @@index([type])
  @@index([itemId])
  @@index([lastMessageAt])
  @@map("conversation")
}

enum ConversationType {
  DIRECT_MESSAGE
  GROUP_CHAT
  ITEM_INQUIRY
}

model ConversationParticipant {
  id             String @id @default(cuid())
  conversationId String @map("conversation_id")
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  userId         String @map("user_id")
  user           User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  joinedAt       DateTime @default(now()) @map("joined_at")
  lastReadAt     DateTime? @map("last_read_at")
  isActive       Boolean @default(true) @map("is_active")
  
  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId])
  @@map("conversation_participant")
}

model Message {
  id             String @id @default(cuid())
  conversationId String @map("conversation_id")
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  senderId       String @map("sender_id")
  sender         User @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  
  content        String @db.Text
  messageType    MessageType @default(TEXT) @map("message_type")
  
  parentMessageId String? @map("parent_message_id")
  parentMessage   Message? @relation("MessageReplies", fields: [parentMessageId], references: [id], onDelete: SetNull)
  replies         Message[] @relation("MessageReplies")
  
  deliveryStatus MessageDeliveryStatus @default(SENT) @map("delivery_status")
  
  createdAt      DateTime @default(now()) @map("created_at")
  editedAt       DateTime? @map("edited_at")
  
  deliveries     MessageDelivery[]
  
  @@index([conversationId, createdAt])
  @@index([senderId])
  @@index([parentMessageId])
  @@map("message")
}

enum MessageType {
  TEXT
  IMAGE
  SYSTEM_NOTIFICATION
  ITEM_SHARE
}

enum MessageDeliveryStatus {
  SENT
  DELIVERED
  READ
  FAILED
}

model MessageDelivery {
  id          String @id @default(cuid())
  messageId   String @map("message_id")
  message     Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  recipientId String @map("recipient_id")
  recipient   User @relation(fields: [recipientId], references: [id], onDelete: Cascade)
  
  deliveredAt DateTime? @map("delivered_at")
  readAt      DateTime? @map("read_at")
  deviceType  String? @map("device_type")
  
  createdAt   DateTime @default(now()) @map("created_at")
  
  @@unique([messageId, recipientId])
  @@index([recipientId])
  @@index([messageId])
  @@map("message_delivery")
}

/// ================================
/// Push Notification System
/// ================================

model DeviceToken {
  id          String @id @default(cuid())
  
  userId      String @map("user_id")
  user        User @relation("UserDeviceTokens", fields: [userId], references: [id], onDelete: Cascade)
  
  token       String @db.Text // Device token (can be long)
  platform    DevicePlatform
  deviceInfo  String? @db.Text @map("device_info") // Device name, model, OS version
  isActive    Boolean @default(true) @map("is_active")
  
  // Notification preferences
  enabledFor  String[] @default(["messages", "orders", "follows"]) @map("enabled_for")
  
  lastUsedAt  DateTime @default(now()) @map("last_used_at")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  @@unique([userId, token])
  @@index([userId])
  @@index([platform])
  @@index([isActive])
  @@map("device_token")
}

enum DevicePlatform {
  IOS
  ANDROID
  WEB
}


